#include <vcl.h>
#pragma hdrstop

#include "SynExportRTF.h"
#include "SynEditStrConst.h"
#include <System.SysUtils.hpp>

using namespace std;
using namespace d2c_system;
using namespace Syneditexport;
using namespace Syneditstrconst;
using namespace Synunicode;
using namespace System;
using namespace System::Sysutils;
using namespace System::Uitypes;

namespace Synexportrtf
{
#define Synexportrtf__0 (TSynEncodings() << seUTF8)



/* TSynExporterRTF */

__fastcall TSynExporterRTF::TSynExporterRTF(TComponent* AOwner)
 : inherited(AOwner),
			fAttributesChanged(false),
			fListColors(nullptr)
{
	fListColors = new TList();
	fDefaultFilter = SYNS_FilterRTF;
	FClipboardFormat = RegisterClipboardFormat(const_cast<LPCWSTR>(CF_RTF));
	FEncoding = seUTF8;
}

__fastcall TSynExporterRTF::~TSynExporterRTF()
{
	delete fListColors;
	fListColors = nullptr;
	//# inherited::Destroy();
}

void __fastcall TSynExporterRTF::Clear()
{
	inherited::Clear();
	if(ASSIGNED(fListColors))
		fListColors->Clear();
}

String __fastcall TSynExporterRTF::ColorToRTF(TColor AColor)
{
	String result;
	int Col = 0;
	Col = ColorToRGB(AColor);
	result = Format(L"\\red%d\\green%d\\blue%d;", ARRAYOFCONST((GetRValue((DWORD) Col), GetGValue((DWORD) Col), GetBValue((DWORD) Col))));
	return result;
}

void __fastcall TSynExporterRTF::FormatAfterLastAttribute()
{

  // no need to reset the font style here...
}

void __fastcall TSynExporterRTF::FormatAttributeDone(bool BackgroundChanged, bool ForegroundChanged, TFontStyles FontStylesChanged)
{
	const String FontTags[4/*# TFontStyle*/] = {L"\\b0", L"\\i0", L"\\ul0", L"\\strike0"};
	TFontStyle AStyle = TFontStyle::fsBold;
  // nothing to do about the color, but reset the font style
	int stop = 0;
	for(stop = (TFontStyle) 3 /*# High(TFontStyle) */, AStyle = (TFontStyle) 0 /*# Low(TFontStyle) */; AStyle <= stop; Inc(AStyle))
	{
		if(FontStylesChanged.Contains(AStyle))
		{
			fAttributesChanged = true;
			AddData(FontTags[AStyle]);
		}
	}
}

void __fastcall TSynExporterRTF::FormatAttributeInit(bool BackgroundChanged, bool ForegroundChanged, TFontStyles FontStylesChanged)
{
	const String FontTags[4/*# TFontStyle*/] = {L"\\b", L"\\i", L"\\ul", L"\\strike"};
	TFontStyle AStyle = TFontStyle::fsBold;
  // background color
	int stop = 0;
	if(BackgroundChanged)
	{
		AddData(Format(L"\\chshdng10000\\chcbpat%d\\cb%d", ARRAYOFCONST((GetColorIndex(fLastBG), GetColorIndex(fLastBG)))));
		fAttributesChanged = true;
	}
  // text color
	if(ForegroundChanged)
	{
		AddData(Format(L"\\cf%d", ARRAYOFCONST((GetColorIndex(fLastFG)))));
		fAttributesChanged = true;
	}
  // font styles
	for(stop = (TFontStyle) 3 /*# High(TFontStyle) */, AStyle = (TFontStyle) 0 /*# Low(TFontStyle) */; AStyle <= stop; Inc(AStyle))
	{
		if(FontStylesChanged.Contains(AStyle))
		{
			AddData(FontTags[AStyle]);
			fAttributesChanged = true;
		}
	}
	if(fAttributesChanged)
	{
		AddData(L" ");
		fAttributesChanged = false;
	}
}

void __fastcall TSynExporterRTF::FormatBeforeFirstAttribute(bool BackgroundChanged, bool ForegroundChanged, TFontStyles FontStylesChanged)
{
	FormatAttributeInit(BackgroundChanged, ForegroundChanged, FontStylesChanged);
}

void __fastcall TSynExporterRTF::FormatNewLine()
{
	AddData(L"\x0d\x0a" L"\\par ");
}

int __fastcall TSynExporterRTF::GetColorIndex(TColor AColor)
{
	int result = 0;
	result = fListColors->IndexOf(((void*) AColor));
	if(result == -1)
		result = fListColors->Add(((void*) AColor));
	return result;
}

String __fastcall TSynExporterRTF::GetFooter()
{
	String result;
	result = L"}";
	return result;
}

String __fastcall TSynExporterRTF::GetFormatName()
{
	String result;
	result = SYNS_ExporterFormatRTF;
	return result;
}

String __fastcall TSynExporterRTF::GetHeader()
{
	String result;
	int i = 0;

	auto GetFontTable = [&]() -> String 
	{
		String result;
		result = String(L"{\\fonttbl{\\f0\\fmodern ") + Font->Name;
		result = result + L";}}\x0d\x0a";
		return result;
	};
	int stop = 0;
	result = String(L"{\\rtf1\\ansi\\ansicpg1252\\uc1\\deff0\\deftab720") + GetFontTable();
  // all the colors
	result = result + L"{\\colortbl";
	for(stop = fListColors->Count - 1, i = 0; i <= stop; i++)
	{
		result = result + ColorToRTF((TColor) (NativeInt) fListColors->Items[i]);
	}
	result = result + L"}\x0d\x0a";
  // title and creator comment
	result = result + L"{\\info{\\comment Generated by the SynEdit RTF " + L"exporter}\x0d\x0a";
	result = result + L"{\\title " + FTitle + L"}}\x0d\x0a";
	if(fUseBackground) /* TODO: use background color */
		result = result + L"\x0d\x0a";
	result = result + Format(L"\\deflang1033\\pard\\plain\\f0\\fs%d ", ARRAYOFCONST((2 * Font->Size)));
	return result;
}

String __fastcall TSynExporterRTF::ReplaceReservedChar(WideChar AChar)
{
	String result;
	result = L"";
	switch(AChar)
	{
		case L'\\':
		result = L"\\\\";
		break;
		case L'{':
		result = L"\\{";
		break;
		case L'}':
		result = L"\\}";
		break;
		default:
		  ;
		break;
	}
	if(AChar > L'\x7f')
	{
		if(AChar <= L'\xff')
			result = String(L"\\'") + LowerCase(IntToHex(int(AChar), 2));
		else

      // SmallInt type-cast is necessary because RTF
      // uses signed 16-Bit Integer for Unicode characters
			result = String(L"\\u") + IntToStr(((short int) AChar)) + L"?";
	}
	return result;
}

TSynEncodings __fastcall TSynExporterRTF::SupportedEncodings()
{
	TSynEncodings result;
	result = Synexportrtf__0;
	return result;
}

bool __fastcall TSynExporterRTF::UseBom()
{
	bool result = false;
	result = false;
	return result;
}


}  // namespace SynExportRTF

